import os
from datetime import datetime
import time

import torch
from einops._torch_specific import allow_ops_in_compiled_graph  # requires einops>=0.6.1
from typing import Tuple, List

from torch_robotics.robots import *
from torch_robotics.torch_utils.torch_utils import get_torch_device
# from mmd.planners.multi_agent import CBS, PrioritizedPlanning
from mmd.planners.multi_agent import End2EndPlanning
from mmd.planners.single_agent import MPD, MPDEnd2End, MPDEnsemble
from mmd.common.constraints import MultiPointConstraint
from mmd.common.conflicts import PointConflict
from mmd.common.trajectory_utils import densify_trajs
from mmd.common import get_start_goal_pos_circle
from mmd.common.pretty_print import *
from mmd.config.mmd_params import MMDParams as params
from mmd.common.experiments import MultiAgentPlanningSingleTrialConfig, MultiAgentPlanningSingleTrialResult, \
    get_result_dir_from_trial_config, TrialSuccessStatus

allow_ops_in_compiled_graph()

TRAINED_MODELS_DIR = '../../data_trained_models/'
device = 'cuda'
device = get_torch_device(device)
tensor_args = {'device': device, 'dtype': torch.float32}

def run_multi_agent_trial(test_config: MultiAgentPlanningSingleTrialConfig):
    # ============================
    # Start time per agent.
    # ============================
    start_time_l = [i * test_config.stagger_start_time_dt for i in range(test_config.num_agents)]
    print(f'start_time_l:{start_time_l}')

    # ============================
    # Arguments for the single diffusion planner.
    # diffusion model & single agent planner
    # ============================
    diffusion_planner_model_args = {
        # config for diffusion model - no change
        'planner_alg': 'mmd',
        'use_guide_on_extra_objects_only': params.use_guide_on_extra_objects_only,  #False
        'n_samples': params.n_samples,  # how many trajs to be generated by one diffusion model (64)
        'n_local_inference_noising_steps': params.n_local_inference_noising_steps,  # 3
        'n_local_inference_denoising_steps': params.n_local_inference_denoising_steps,
        'start_guide_steps_fraction': params.start_guide_steps_fraction,
        'n_guide_steps': params.n_guide_steps,
        'n_diffusion_steps_without_noise': params.n_diffusion_steps_without_noise,
        # config for low-level planner
        'weight_grad_cost_collision': params.weight_grad_cost_collision,
        'weight_grad_cost_smoothness': params.weight_grad_cost_smoothness,
        'weight_grad_cost_constraints': params.weight_grad_cost_constraints,
        'weight_grad_cost_soft_constraints': params.weight_grad_cost_soft_constraints,
        'factor_num_interpolated_points_for_collision': params.factor_num_interpolated_points_for_collision,
        'trajectory_duration': params.trajectory_duration,
        'device': params.device,
        'debug': params.debug,
        'seed': params.seed,
        'results_dir': params.results_dir,
        'trained_models_dir': TRAINED_MODELS_DIR,
    }
    end_to_end_planner_model_args = {
        'start_time_l': start_time_l,
        'runtime_limit': test_config.runtime_limit,
        # 'n_diffusion_steps': test_config.n_diffusion_steps,
        'conflict_type_to_constraint_types': {PointConflict: {MultiPointConstraint}},
        'device': params.device,
        # device, seed, debug需要挪出来吗？
    }

    # ============================
    # Create a results directory.
    # ============================
    results_dir = get_result_dir_from_trial_config(test_config, test_config.time_str, test_config.trial_number)
    os.makedirs(results_dir, exist_ok=True)
    num_agents = test_config.num_agents

    # ============================
    # Get planning problem.
    # ============================
    # If want to get random starts and goals, then must do that after creating the reference task and robot.
    start_l = test_config.start_state_pos_l
    goal_l = test_config.goal_state_pos_l
    global_model_ids = test_config.global_model_ids
    agent_skeleton_l = test_config.agent_skeleton_l
    print(f'debug: global_model_ids: {global_model_ids}')

    # ============================
    # Transforms and model tiles setup.
    # ============================
    # Create a reference planner from which we'll use the task and robot as the reference on in CBS.
    # Those are used for collision checking and visualization. This has a skeleton of all tiles.
    reference_agent_skeleton = [[r, c] for r in range(len(global_model_ids))
                                for c in range(len(global_model_ids[0]))]

    # ============================
    # Transforms from tiles to global frame.
    # ============================
    tile_width = 2.0
    tile_height = 2.0
    global_model_transforms = [[torch.tensor([x * tile_width, -y * tile_height], **tensor_args)
                                for x in range(len(global_model_ids[0]))] for y in range(len(global_model_ids))]    
    print(f'debug: global model tansforms:{global_model_transforms}')

    # ============================
    # Parse the single agent planner class name.
    # emmm in this case maybe i should start by parser the model?
    # what exactly was done in the low-level planner
    # ============================    
    if test_config.single_agent_planner_class == "MPDe2e":
        planner_class = MPDEnd2End
    elif test_config.single_agent_planner_class == "MPD":
        planner_class = MPD
    elif test_config.single_agent_planner_class == "MPDEnsemble":
        planner_class = MPDEnsemble
    else:
        raise ValueError(f'Unknown single agent planner class: {test_config.single_agent_planner_class}')

    # ============================
    # Create reference agent planner.
    # ============================
    # And for the reference skeleton.
    reference_task = None
    reference_robot = None
    reference_agent_transforms = {}
    reference_agent_model_ids = {}
    for skeleton_step in range(len(reference_agent_skeleton)):
        skeleton_model_coord = reference_agent_skeleton[skeleton_step]
        reference_agent_transforms[skeleton_step] = global_model_transforms[skeleton_model_coord[0]][
            skeleton_model_coord[1]]
        reference_agent_model_ids[skeleton_step] = global_model_ids[skeleton_model_coord[0]][
            skeleton_model_coord[1]]
    reference_agent_model_ids = [reference_agent_model_ids[i] for i in range(len(reference_agent_model_ids))]
    # Create the reference low level planner
    diffusion_planner_model_args['start_state_pos'] = torch.tensor([0.5, 0.9], **tensor_args)  # This does not matter.
    diffusion_planner_model_args['goal_state_pos'] = torch.tensor([-0.5, 0.9], **tensor_args)  # This does not matter.
    diffusion_planner_model_args['model_ids'] = reference_agent_model_ids  # This matters.
    diffusion_planner_model_args['transforms'] = reference_agent_transforms  # This matters.

    if test_config.single_agent_planner_class in ["MPD", "MPDe2e"]:
        diffusion_planner_model_args['model_id'] = reference_agent_model_ids[0]
    
    reference_single_agent_planner = planner_class(**diffusion_planner_model_args)
    reference_task = reference_single_agent_planner.task
    reference_robot = reference_single_agent_planner.robot

    # ============================
    # Run trial.
    # ============================
    exp_name = f'mmd_single_trial'

    # Transform starts and goals to the global frame. Right now they are in the local tile frames.
    start_l = [start_l[i] + global_model_transforms[agent_skeleton_l[i][0][0]][agent_skeleton_l[i][0][1]]
               for i in range(num_agents)]
    goal_l = [goal_l[i] + global_model_transforms[agent_skeleton_l[i][-1][0]][agent_skeleton_l[i][-1][1]]
              for i in range(num_agents)]
    # ============================
    # Create global transforms for each agent's skeleton.
    # ============================
    # Each agent has a dict entry. Each entry is a dict with the skeleton steps (0, 1, 2, ...), mapping to the
    # model transform.
    agent_model_transforms_l = []
    agent_model_ids_l = []
    for agent_id in range(num_agents):
        agent_model_transforms = {}
        agent_model_ids = {}
        for skeleton_step in range(len(agent_skeleton_l[agent_id])):
            skeleton_model_coord = agent_skeleton_l[agent_id][skeleton_step]
            agent_model_transforms[skeleton_step] = global_model_transforms[skeleton_model_coord[0]][
                skeleton_model_coord[1]]
            agent_model_ids[skeleton_step] = global_model_ids[skeleton_model_coord[0]][skeleton_model_coord[1]]
        agent_model_transforms_l.append(agent_model_transforms)
        agent_model_ids_l.append(agent_model_ids)
    # Change the dict of the model ids to a list sorted by the skeleton steps.
    agent_model_ids_l = [[agent_model_ids_l[i][j] for j in range(len(agent_model_ids_l[i]))] for i in
                         range(num_agents)]
    
    # ============================
    # Create the single agent planners.
    # ============================
    planners_creation_start_time = time.time()
    single_agent_planner_l = []
    for i in range(num_agents):
        single_agent_planner_model_args_i = diffusion_planner_model_args.copy()
        single_agent_planner_model_args_i["start_state_pos"] = start_l[i]
        single_agent_planner_model_args_i['goal_state_pos'] = goal_l[i]
        single_agent_planner_model_args_i['model_ids'] = agent_model_ids_l[i]
        single_agent_planner_model_args_i["transforms"] = agent_model_transforms_l[i]
        if test_config.single_agent_planner_class in ["MPD", "MPDe2e"]:
            single_agent_planner_model_args_i["model_id"] = agent_model_ids_l[i][0]
        single_agent_planner_l.append(planner_class(**single_agent_planner_model_args_i))
    print('Planners creation time:', time.time() - planners_creation_start_time)
    print("\n\n\n\n")

    # ============================
    # Create the multi agent planner.
    # don't really exist, but we use sth like PP
    # ============================
    planner = End2EndPlanning(single_agent_planner_l,
                             start_l,
                             goal_l,
                             reference_task=reference_task,
                             reference_robot=reference_robot,
                             **end_to_end_planner_model_args)
    
    # ============================
    # Plan.
    # ============================
    startt = time.time()
    state_dim = single_agent_planner_l[0].state_dim
    batch_size = params.n_samples
    shape = (num_agents, batch_size, params.horizon, state_dim)
    paths_l, num_ct_expansions, trial_success_status, num_collisions_in_solution = \
        planner.plan(runtime_limit=test_config.runtime_limit, 
                     shape=shape,
                     t_start_guide=single_agent_planner_l[0].t_start_guide,
                     n_diffusion_steps=test_config.n_diffusion_steps,
                     n_diffusion_steps_without_noise=single_agent_planner_l[0].n_diffusion_steps_without_noise,
                    )
    planning_time = time.time() - startt
    # Print planning times.
    print(GREEN, 'Planning times:', planning_time, RESET)

    # ============================
    # Gather stats.
    # ============================
    # The agent paths. Each entry is of shape (H, 4).
    single_trial_result = MultiAgentPlanningSingleTrialResult()
    single_trial_result.agent_path_l = paths_l
    # Success.
    single_trial_result.success_status = trial_success_status
    # Number of collisions in the solution.
    single_trial_result.num_collisions_in_solution = num_collisions_in_solution    
    # Planning time.
    single_trial_result.planning_time = planning_time

    # Number of agent pairs in collision.

    # If not successful, return here.
    if trial_success_status:
        pass
    # ============================
    # Save the results and config.
    # ============================
    print(GREEN, single_trial_result, RESET)
    results_dir_uri = f'file://{os.path.abspath(results_dir)}'
    print('Results dir:', results_dir_uri)
    single_trial_result.save(results_dir)
    test_config.save(results_dir)

    # ============================
    # Render.
    # ============================
    if trial_success_status and len(paths_l) > 0:
        planner.render_paths(paths_l,
                             output_fpath=os.path.join(results_dir, f'{exp_name}.gif'),
                             animation_duration=0,
                             plot_trajs=True,
                             show_robot_in_image=True)
        if test_config.render_animation:
            paths_l = densify_trajs(paths_l, 1)  # <------ Larger numbers produce nicer animations. But take longer to make too.
            planner.render_paths(paths_l,
                                 output_fpath=os.path.join(results_dir, f'{exp_name}.gif'),
                                 plot_trajs=True,
                                 animation_duration=10)





    

if __name__ == '__main__':
    test_config_single_tile = MultiAgentPlanningSingleTrialConfig()
    test_config_single_tile.num_agents = 3
    test_config_single_tile.instance_name = "test"
    # test_config_single_tile.multi_agent_planner_class = "XECBS" 
    test_config_single_tile.single_agent_planner_class = "MPDe2e" # Or "MPDEnsemble"
    test_config_single_tile.stagger_start_time_dt = 0
    test_config_single_tile.runtime_limit = 60 * 3  # 3 minutes.
    test_config_single_tile.time_str = datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
    test_config_single_tile.render_animation = True  # Change the `densify_trajs` call above to create nicer animations.

    example_type = "single_tile"
    # example_type = "multi_tile"
    # ============================
    # Single tile.
    # ============================
    if example_type == "single_tile":
        # Choose the model to use. A model is for a map/robot combination.
        # test_config_single_tile.global_model_ids = [['EnvEmpty2D-RobotPlanarDisk']]
        test_config_single_tile.global_model_ids = [['EnvEmptyNoWait2D-RobotPlanarDisk']]
        # test_config_single_tile.global_model_ids = [['EnvConveyor2D-RobotPlanarDisk']]
        # test_config_single_tile.global_model_ids = [['EnvHighways2D-RobotPlanarDisk']]
        # test_config_single_tile.global_model_ids = [['EnvDropRegion2D-RobotPlanarDisk']]

        # Choose starts and goals.
        test_config_single_tile.agent_skeleton_l = [[[0, 0]]] * test_config_single_tile.num_agents
        torch.random.manual_seed(10)
        # start & goal are uniformly distributed on a circle with radiu 0.8
        test_config_single_tile.start_state_pos_l, test_config_single_tile.goal_state_pos_l = \
        get_start_goal_pos_circle(test_config_single_tile.num_agents, 0.8)
        print("Starts:", test_config_single_tile.start_state_pos_l)
        print("Goals:", test_config_single_tile.goal_state_pos_l)
        test_config_single_tile.n_diffusion_steps = 50

        run_multi_agent_trial(test_config_single_tile)
        print(GREEN, 'OK.', RESET)
